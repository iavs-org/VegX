---
title: "Using the VegX R package"
author: "IAVS Ecoinformatics Working Group"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: TRUE
vignette: >
  %\VignetteIndexEntry{VegX package user's manual}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## About this manual

In this vignette you will learn how to use the **VegX R package** to map, integrate and harmonize vegetation data using the Veg-X standard (v. 2.0). For the examples, we use the data sets provided in the package. If you do not know what the Veg-X standard is, please refer to vignette **The Veg-X exchange standard**. Here we refer to elements of the Veg-X standard. Readers should refer to the same vignette to understand the definition of these elements and their logical relationships.

## Package users and their main interests
We envisage two different kinds of users of the VegX package:

* **Vegetation data providers**: These are people that are in possession of plot vegetation data (i.e. plot database managers or people having their own spread sheets) and get requests to share its data with third parties. Data providers would benefit from VegX package, in that they would perform the mapping of their source data into Veg-X only once, and then they would send the Veg-X file to any party requesting access to data.  The functions most interesting to data providers are:
    + Create new VegX documents
    + Add information about plot location, plot shape and site characteristics.
    + Add vegetation observations of different kinds: individual plants, aggregated cover values, strata observations...
    + Add site observations (e.g. abiotic measurements).
    + Provide information about the taxon concepts related to organism identifications.
    + Provide information about the research project and contact information.
    + Write Veg-X XML files or other supported export formats.

* **Vegetation data integrators**: These are people interested in gathering data from different sources, for the sake of compiling a new vegetation plot data base or conducting analyses based on integrated data sets.
    + Load Veg-X XML files.
    + Merge several Veg-X objects from different sources.
    + Assess the degree of compatibility of the different source data.
    + Harmonize measurement units and taxonomic nomenclature across data sets.
    + Generate new observations at a given level of vegetation resolution by aggregating data at a lower level (e.g. from individual tree diameters to basal area estimates).
    + Export data into formats suitable for analysis.


## Installing the package and loading source data

The **VegX package** is currently distributed from [GitHub](https://github.com). To install it, you should have package ``devtools`` installed and use the following command: ``devtools::install_github("miquelcaceres/VegX", build_vignettes=TRUE)``. Assuming that the package is already installed you begin by loading it, which results in the required package *XML* also being loaded:
```{r load VegX}
library(VegX)
```

User's of the VegX package are expected to know how import their source data into R, either using a database connection or by reading files in diverse formats (e.g. txt, csv, xlsx, ...). For the examples of this manual, we will use three data sets that were extracted from the [New Zealand National Vegetation Survey (NVS) Databank](https://nvs.landcareresearch.co.nz/). These are subsets of the original datasets prepared for demonstration purposes only.

+ **Mokihinui forest**: Forest and riparian data from 5 plots from the west coast of South Island (New Zealand).  The data comprises i) site information from each plot; ii) cover scores of taxa within height strata; and iii) dbh measurement of individual trees.
+ **Mt Fyffe forest**: Forest data from five permanent plots from the east coast of South Island (New Zealand).  The data comprises i) site information from each plot; ii) cover scores of taxa within height strata; iii) dbh measurement of individual trees within subplots that fully partition the permanent plot; iv) counts of saplings within subplots that fully partition the permanent plot; and v) counts of seedlings within height strata within subplots that sample the permanent plot.  Two full measurements of the permanent plots are provided.
+ **Takitimu grassland**: Alpine grassland data from 5 plots from the southern South Island (New Zealand).  The data comprises i) site information from each plot; ii) frequency values for plant taxa based on observations within subplots along transects; iii) groundcover; iv) disturbance.

Each of the three data sets contains different tables, corresponding to plot location, site observations, taxon observations, ... For simplicity, we reduced the number of plots in each example data set to five, although some data sets contain subplots. As the three data sets are included with the package, we load  the data from the three data sets into the R workspace using:
```{r load source data}
data(mokihinui)
data(mtfyffe)
data(takitimu)
ls()
```


## Creating a new Veg-X document

Before mapping any data to the Veg-X standard, we need to create a new (empty) document for each data set, using ``newVegX()``:
```{r init}
moki_vegx = newVegX()
mtfyffe_vegx = newVegX()
taki_vegx = newVegX()
```
The output from ``print()`` command reveals that a Veg-X document is defined in R using a S4 class, each of the different *slots* being vectors of the main elements of the Veg-X document: 
```{r print}
print(moki_vegx)
```
Printing a Veg-X object will normally result in too much data being shown in the console output. More user-friendly information about the Veg-X object can be obtained using the function ``summary()``, which tell us how many instances we have of each of the main elements:
```{r summary empty}
summary(moki_vegx)
```
Of course, ``moki_vegx`` is now empty (as are the other two VegX objects). 

In the following sections we will progressively add content to the VegX objects. When using the VegX package, the order in which we introduce data to VegX documents is not particularly important, as elements are created as needed. Nevertheless, we will introduce the different functions that add data following a logical sequence. Thus, we begin by introducing plot and survey information, followed by observations of individual organisms, taxa, strata, etc. Later sections of the manual deal with functions that facilitate data integration and harmonization.

## Adding plot and survey data to Veg-X documents

### Project, plot and observation dates
In this subsection we show how to introduce information about plot names and survey dates. We start with the **Mokinihui forest data set**, by inspecting the data in the data frame ``moki_site``:
```{r inspect data}
head(moki_site, 3)

```
The data frame has many columns, covering both plot shape, site topography... but the most important columns to parse are ``Plot``, ``Subplot`` and ``PlotObsStartDate``, because these specify the space and time context in which vegetation surveys were made. Other columns specify IDs, but these are specific to the data base where this data comes from, and Veg-X documents have their own internal IDs, so we will not import them now. 

In order to import data into Veg-X documents, we almost always need a **mapping** *between the names of elements in the Veg-X standard and the names of columns in the data table used as input*. For example, in the following code we define that column ``"Project"`` in the source data table contains the information about the *projectTitle* in Veg-X, column ``"Plot"`` contains the information about the *plotName*  element, and so on:

```{r mapping}
mapping = list(projectTitle = "Project", plotName = "Plot", subPlotName = "Subplot",
               obsStartDate = "PlotObsStartDate", obsEndDate = "PlotObsStopDate")
```

Once the mapping is defined, we can import the data using ``addPlotObservations()``:

```{r add plot obs}
# Adds information about projects, plots and plot observations (no measurements yet)
moki_vegx = addPlotObservations(moki_vegx, moki_site, mapping = mapping)
```
The console output of the add function informs us of the steps that took place and which modified our Veg-X R object (note that we could store the result in a different object instead of replacing ``moki_vegx``). 25 plots were identified, all belonging to the same research project, and one plot observation was read for each plot. If we call again the ``summary`` function we will see a change in the number of data elements:
```{r summary}
summary(moki_vegx)
```
Note that among the 25 plots there are 20 subplots (in fact, 4 for each parent plot). If we want to inspect, at any time, the information of a Veg-X document in more detail, we can use the function ``showElementTable()``, indicating which of the main Veg-X elements we want to inspect:
```{r show plot obs}
head(showElementTable(moki_vegx, "plotObservation"),10)
```

Let's now do the same for the **Mt Fyffe forest data set**. Since it comes from the same data base (NVS), data table have similar column names and we will not show them again. In this case, however, there is no information about the sampling end date, only the start date. We modify our mapping accordingly and we call ``addPlotObservations()`` :
```{r add plot obs mtfyffe}
mapping = list(projectTitle = "Project", plotName = "Plot", subPlotName = "Subplot", 
               obsStartDate = "PlotObsStartDate")
mtfyffe_vegx = addPlotObservations(mtfyffe_vegx, mtfyffe_site, mapping)
summary(mtfyffe_vegx)
```
In this source data set there are many more subplots for each plot, and each plot/subplot was visited twice (in 1980 and 2007-2008). Moreover, each survey corresponds to a different project. Veg-X does not require projects to be equated to surveys, but in this data set it happens to be like this. We now turn our attention to the **Takitimu grassland data set**. 

```{r add plot obs taki}
mapping = list(projectTitle = "Project", plotName = "Plot", subPlotName = "Subplot", 
               obsStartDate = "PlotObsStartDate")
taki_vegx = addPlotObservations(taki_vegx, taki_site, mapping)
summary(taki_vegx)
```
According to this summary, this third data set contains again 5 plots, but with no subplots, so even if we specified a map for subplots none was detected.

### Project information
In the previous subsection, we specified a mapping for research project titles, and this lead to the creation of *project* elements in Veg-X documents. However, we did not introduce any data regarding the project description:
```{r empty project info moki}
showElementTable(moki_vegx, "project")
```
Veg-X package provides function ``fillProjectInformation()`` to fill project data. It can be used to fill the data for an existing project (identified by its title) or to define a new project. As an example, we provide the information for the project that lead to the collection of data in the Mokihinui forest:
```{r fill project info moki}
moki_vegx = fillProjectInformation(moki_vegx, "MOKIHINUI HYDRO PROPOSAL - LOWER GORGE 2011",
              personnel = c(contributor = "Susan K. Wiser"),
              abstract = paste("Characterise the forest and riparian vegetation",
                               "in the lower Mokihinui gorge,",
                               "and compare this with the vegetation",
                               "in (a) North Branch gorge of Mokihinui",
                               "and (b) Karamea catchment."),
             studyAreaDescription = paste("Mokihinui and Karamea catchments.",
                                          " Forest riparian habitat."))

showElementTable(moki_vegx, "project")
```
Note that filling the information about project led to the definition of personnel involved in the project. In Veg-X any individual/organization/position involved in the creation of a data set is stored in a *party* element. We may fill contact information for *party* elements using the  function ``fillPartyInformation()``.

### Plot coordinates

The next pieces information that one would normally like to introduce are the geographic location of plots (sampling dates were already mapped with ``addPlotObservations()``). We thus take a look at ``moki_loc`` data frame:
```{r inspect plot loc moki}
head(moki_loc, 3)
```
Locations are expressed using different coordinate systems, but the easiest and more common way of exchanging geographic information is through latitude and longitude. Hence, we define a new mapping and use the function ``addPlotLocations()``:
```{r add plot loc moki}
mapping = list(plotName = "Plot", x = "Longitude", y = "Latitude")
moki_vegx = addPlotLocations(moki_vegx, moki_loc, mapping)
```
When defining the mapping ``x``and ``y``are used to map coordinates. We should also include ``plotName``, because otherwise the function does not know how to match coordinates with the plots already defined in ``moki_vegx`` (``subPlotName`` should be included if coordinates were available for subplots). The console output indicates that no new plots have been added (they were previously defined), but they would if we had started populating the Veg-X object using ``addPlotLocations()`` and an empty document. When can inspect the data recently entered using the following command:

```{r inspect plot loc res moki}
head(showElementTable(moki_vegx, "plot"),3)
```
When calling ``showElementTable()`` for plot elements we are shown the plot/subplot relationships. Note that subplots have no explicit coordinates associated to them (they are not given in ``moki_loc``). It is up to the user to provide them in the source data. Using the same mapping we can parse the coordinates of the **Mt Fyffe forest data set**:
```{r add plot loc mtfyffe}
mtfyffe_vegx = addPlotLocations(mtfyffe_vegx, mtfyffe_loc, mapping)
```
Apparently, 10 records were parsed, but only five plots (excluding subplots) are available. Coordinate records are duplicated in ``mtfyffe_loc``, once for each survey. Function ``addPlotLocations()`` will always keep the last location records of each plot. Finally, we parse plot coordinates for the **Takikimu grassland data set**, realizing that they are lacking for one of the plots.

```{r add plot loc taki}
taki_vegx = addPlotLocations(taki_vegx, taki_loc, mapping)
```
Function ``addPlotLocations()`` accepts coordinates in any spatial reference system, which is specified using parameter ``proj4string``. Setting ``toWGS84 = TRUE`` will indicate the function that it should attempt translating the input coordinates into longitude and latitude, but this was not necessary in our examples. 

### Plot elevation
While ``x`` and ``y`` specify horizontal plot position, the vertical position of a plot is specified using elevation (normally above sea level). Since plot elevation is a **measurement**, it is important to specify a **measurement method** (i.e. instruments) and a **measurement scale** (i.e. measurement units) because this metadata decreases potential errors when pooling data from different sources. In the Veg-X standard, this information is specified via defining *method* and *attribute* elements, whereas the VegX package has a S4 class named ``VegXMethod`` that encapsulates both things. Users can define their own methods, but the package provides function ``predefinedMeasurementMethod()`` to easily define methods for the most common variables. For example, we can define the measurement for elevation in meters above sea level using:
```{r method plot elev moki}
elevMethod = predefinedMeasurementMethod("Elevation/m")
```
Plot elevation is added to Veg-X documents using ``addPlotLocations()`` as before. However, in our Mokihinui data set elevation is included in the data frame ``moki_site`` (and not ``moki_loc``), so we could not add it using the same call that we used for plot coordinates. Having our elevation method defined, we use again:
```{r add plot elev moki}
mapping = list(plotName = "Plot", elevation = "Altitude")
moki_vegx = addPlotLocations(moki_vegx, moki_site, mapping, 
                             methods = c(elevation = elevMethod))
```
Again, only the parent plots have elevation data, and the records of subplots are empty. If we inspect again the *plot* elements of our document we find that elevation data has been added to plot coordinates:
```{r inspect plot elev res moki}
head(showElementTable(moki_vegx, "plot"),3)
```
Analogous calls to ``addPlotLocations()`` can be made to fill elevation data for the **Mt Fyffe forest** and the **Takitimu grassland** data sets:
```{r add plot elev taki}
mtfyffe_vegx = addPlotLocations(mtfyffe_vegx, mtfyffe_site, mapping,
                                methods = c(elevation = elevMethod))
taki_vegx = addPlotLocations(taki_vegx, taki_site, mapping, 
                             methods = c(elevation = elevMethod))
```

### Plot geometry

By plot geometry, we refer to plot area, shape and dimensions. Veg-X allows different plot shapes (circle, rectangle, line or polygon), and each plot shape implies different dimensions. Plot geometry is specified using function ``addPlotGeometries()`` and, analogously to ``addPlotLocation()``, the function will replace any previous information regarding geometry. We start by looking at the plot geometry fields in the **Mokihinui forest data set** table ``moki_site``:
```{r inspect plot geom moki}
names(moki_site)
table(moki_site$Shape)
```
After realizing that plot/subplot shapes are rectangular and both length and width are available, we define the following mapping for rectangular (or square) plots:
```{r mapping plot geom moki}
mapping = list(plotName = "Plot", subPlotName = "Subplot",
               area = "PlotArea", shape = "Shape",
               length = "PlotRectangleLength01", width = "PlotRectangleLength02")
```
Like **elevation**, plot area and plot dimensions are **measurements** so we need to define them. After checking the units used in ``moki_site`` we define methods for plot area and plot dimensions, again using function ``predefinedMeasurementMethod()``:
```{r define geom methods}
areaMethod = predefinedMeasurementMethod("Plot area/m2")
dimensionMethod = predefinedMeasurementMethod("Plot dimension/m")
```
We are now ready to import plot geometry using ``addPlotGeometries()``, where we specify both the mapping and the list of methods corresponding to the Veg-X element names of the mapping (i.e. ``area``, ``length`` and ``width`` for rectangular plots):
```{r add plot geom moki}
moki_vegx = addPlotGeometries(moki_vegx, moki_site, mapping,
              list(area = areaMethod, width = dimensionMethod, length = dimensionMethod))
head(showElementTable(moki_vegx, "plot"),3)
```
Like before, no new plots were added, as previous call functions had already defined them. In the call to ``showElementTable()`` we have now the plot geometry added to the plot location and plot/subplot relationships. Importing plot geometry for the **Takitimu grassland data** set is analogous: 
```{r add plot geom taki}
taki_vegx = addPlotGeometries(taki_vegx, taki_site, mapping,
              list(area = areaMethod, width = dimensionMethod, length = dimensionMethod))
head(showElementTable(taki_vegx, "plot"))
```
In the case of **Mt Fyffe forest data set**, shape is missing for many of plots. Other plots are circular but *radius* is not defined in the ``mtfyffe_site`` data frame. 

```{r inspect plot geom mtfyffe}
names(mtfyffe_site)
table(mtfyffe_site$Shape)
```
Hence, we define the following mapping, and a call ``addPlotGeometries()`` produces the following result:
```{r add plot geom mtfyffe}
mapping = list(plotName = "Plot", subPlotName = "Subplot",
               area = "PlotArea", shape = "Shape")
mtfyffe_vegx = addPlotGeometries(mtfyffe_vegx, mtfyffe_site, mapping,
                                 list(area = areaMethod))
head(showElementTable(mtfyffe_vegx, "plot"), 3)
```

### Other static site characteristics
To finish with static plot information, the next data we should add to our Veg-X documents is plot topography. This can be done using function ``addSiteCharacteristics()``, which also allows introducing other site attributes that are considered static in time for the time scales of vegetation dynamics (e.g. geological parent material). Having inspected data frame ``moki_site`` before makes us suspect that an appropriate mapping is:
```{r mapping site topo moki}
sitemapping = list(plotName = "Plot", subPlotName = "Subplot",
                   slope = "PlotSlope", aspect = "PlotAspect")

```
Since slope and aspect are again **measurements**, we also need to provide methods for them. After checking the units in the source data we define the following methods:
```{r methods site topo moki}
slopeDeg = predefinedMeasurementMethod("Slope/degrees")
aspectDeg = predefinedMeasurementMethod("Aspect/degrees")
```
and we are ready to import the data:
```{r add site topo moki}
moki_vegx = addSiteCharacteristics(moki_vegx, moki_site, mapping = sitemapping,
                measurementMethods = list(slope = slopeDeg, aspect = aspectDeg))

head(showElementTable(moki_vegx, "plot"), 3)
```
Again, no new plots are added, and missing values correspond to subplots. When calling ``showElementTable()`` the topography information is shown along with the plot information previously added. Since the site data frames for **Mt Fyffe forest** and **Takitimu grassland** data sets have the same structure as that of Mokihinui, adding topography information for the former data sets is rather straightforward:

```{r add site topo mtfyffe}
mtfyffe_vegx = addSiteCharacteristics(mtfyffe_vegx, mtfyffe_site, mapping = sitemapping,
                measurementMethods = list(slope = slopeDeg, aspect = aspectDeg))
taki_vegx = addSiteCharacteristics(taki_vegx, taki_site, mapping = sitemapping,
                measurementMethods = list(slope = slopeDeg, aspect = aspectDeg))
```

## Adding observation data

In the beginning of the previous section we specified plot observation dates for the plots of our examples, using function ``addPlotObservation()``. While this function defines survey events for plots, it does not add any observation or measurement made on plot visits. In this section we show how to add such information.

### Individual organism observations
First we focus on observations made on individual organisms (e.g. diameter values measured on individual trees). Since individual organisms can be labelled and re-measured in different plot surveys, Veg-X uses the element *individualOrganism* to keep track of the organism itself. Then, different elements *individualOrganismObservations* can be used to contain measurements made on the individual organism each time there was an observation of the plot (i.e. each time the plot was revisited). The individual organism (e.g. a particular tree) is uniquely identified using the plot name and an organism label (i.e. a tag on the specimen). Thus, the same label can be repeated in different plots without causing data integrity problems. Individual organisms and their observations are added to Veg-X using the function ``addIndividualOrganismObservations()``. We first show how it works using the data frame ``moki_dia``, which contains diameter measurements for trees in the **Mokihinui forest** data set:
```{r inspect ind obs moki}
head(moki_dia, 3)
unique(moki_dia$Identifier)
```
Note that there is a column called ``Identifier`` but no data in it. Fortunately, the data set includes a single survey, so that there is no need to provide labels for individual organisms. Hence, we can define our mapping as follows:
```{r mapping ind obs moki}
mapping = list(plotName = "Plot", subPlotName = "Subplot", obsStartDate = "PlotObsStartDate",
               taxonName = "NVSSpeciesName", diameterMeasurement = "Diameter")
```
If no mapping is provided for *individualOrganismLabel*, function ``addIndividualOrganismObservations()`` will assume that each record corresponds to a different organism. To define the identity of organisms we can use mapping for either ``organismName`` or ``taxonName``. The first option is used to specify names that are not taxa (e.g. "tree #1", "tree #2", or morphospecies), while the second option explicitly identifies names as taxa. After defining a method for diameter measurements (diameter at breast height in cm), the call to the function produces the following output:
```{r add ind obs moki}
diamMeth = predefinedMeasurementMethod("DBH/cm")
moki_vegx = addIndividualOrganismObservations(moki_vegx, moki_dia, mapping = mapping,
                                      methods = c(diameterMeasurement = diamMeth))
```
where we see that the number of individual organisms is equal to the number of observations. We can inspect the added individual organism observations using:
```{r results ind obs moki}
head(showElementTable(moki_vegx, "individualOrganismObservation"), 3)
```
Note that the column ``individualOrganismLabel`` contains labels created by the function itself, by numbering all individuals of each plot. The call to function ``addIndividualOrganismObservations()`` also led to the definition of elements *organismName* (used to store the different organism/taxon names that are used in the Veg-X document) and elements *organismIdentity* (which define the identity of organisms, as with links to organism names and taxon concepts). Let's inspect the latter:
```{r results ind obs moki identity}
head(showElementTable(moki_vegx, "organismIdentity"), 3)
```
In this case, the identity is simply the species name coming from the source data, but it could be another name considered nomenclaturally more valid for the same species. 

The **Mt Fyffe forest** data set also contains tree diameter measurements, but in this case there have been two surveys, so in order to add individual tree observations we need the mapping ``individualOrganismLabel`` to specify which column identifies each tree in each plot:

```{r inspect ind obs mtfyffe}
head(mtfyffe_dia, 3)
mapping = list(plotName = "Plot", subPlotName = "Subplot", obsStartDate = "PlotObsStartDate",
               taxonName = "NVSSpeciesName", individualOrganismLabel = "Identifier", 
               diameterMeasurement = "Diameter")
```
Since the diameter measurement method is the same as before, we can directly run `addIndividualOrganismObservations()`` and inspect the result:
```{r add ind obs mtfyffe}
mtfyffe_vegx = addIndividualOrganismObservations(mtfyffe_vegx, mtfyffe_dia, 
                                  mapping = mapping,
                                  methods = c(diameterMeasurement = diamMeth))

head(showElementTable(mtfyffe_vegx, "individualOrganismObservation"), 3)
```
Note that in this case the number of observations of individual trees is higher than the number of trees, because of the repeated measurements. Although we will not show it here in any example, it is possible to associate organism observations to particular heights where organisms are observed or to particular strata, by linking them to stratum observations in the same way as we did for aggregate organism observations.

### Aggregate organism observations

Aggregate organism observations include measurements that apply to a set of organisms collectively, normally all organisms of the same species identity. The most common examples are abundance values (e.g. cover) for species. Function ``addAggregateOrganismObservations()`` can be used to import such data into a VegX document. We first inspect the **Mokihinui forest** data frame ``moki_tcv`` to decide what information should be mapped:
```{r inspect taxon obs moki}
head(moki_tcv,3)
```
As before, taxon names can be drawn from column ``NVSSpeciesName``. Column ``Tier`` contains information about the stratum where species were recorded, whereas column ``Category`` contains cover values codified in a cover ordinal scale. First, we define a mapping for these variables as well as for plot and observation start date, which together specify a *plotObservation* (aggregate organism observations were not done in subplots for this data set).
```{r mapping taxon obs moki}
mapping = list(plotName = "Plot", obsStartDate = "PlotObsStartDate", 
               taxonName = "NVSSpeciesName",
               stratumName = "Tier", cover = "Category")
```
In order to parse cover values, we could use a method of percent cover, but in this data set cover is specified using cover classes. Thus, we need to define an ordinal scale that can be used to interpret ``Category`` values; this can be done with function ``defineOrdinalScaleMethod()``:
```{r cover scale def}
coverscale = defineOrdinalScaleMethod(name = "Recce cover scale",
                   description = "Recce recording method by Hurst/Allen",
                   subject = "plant cover",
                   citation = "Hurst, JM and Allen, RB. (2007) The Recce method for describing 
                               Zealand vegetation – Field protocols. Landcare Research, Lincoln.",
                   codes = c("P","1","2","3", "4", "5", "6"),
                   quantifiableCodes = c("1","2","3", "4", "5", "6"),
                   breaks = c(0, 1, 5, 25, 50, 75, 100),
                   midPoints = c(0.05, 0.5, 15, 37.5, 62.5, 87.5),
                   definitions = c("Presence", "<1%", "1-5%","6-25%", "26-50%", 
                                   "51-75%", "76-100%"))
```
As the source data specifies taxon abundances within vegetation strata, we also need to supply information on how the strata are defined. The **VegX R package** provides three different ways of defining strata: by heights, by categories and using a mixed approach. This last option is used in the following code:
```{r moki strata def}
moki_strataDef = defineMixedStrata(name = "Recce strata",
                   description = "Standard Recce stratum definition",
                   citation = "Hurst, JM and Allen, RB. (2007) The Recce method for describing 
                               Zealand vegetation – Field protocols. Landcare Research, Lincoln.",
                   heightStrataBreaks = c(0, 0.3,2.0,5, 12, 25, 50),
                   heightStrataNames = paste0("Tier ",1:6),
                   categoryStrataNames = "Tier 7",
                   categoryStrataDefinition = "Epiphytes")
```
Having the mapping, the cover scale and the stratum definition we can proceed to import species cover values by strata using function ``addAggregateOrganismObservations()``:
```{r add taxon obs moki}
moki_vegx = addAggregateOrganismObservations(moki_vegx, moki_tcv, mapping,
                        methods = c(cover=coverscale),
                        stratumDefinition = moki_strataDef)
```
Note that the both the stratum definition and the cover scale contain *methods* that are added to the Veg-X document. The strata themselves are also added to the document (i.e. *stratum* elements). Other elements that are added are organism identities (i.e. taxon names), stratum observations (because species were observed while focusing on particular strata) and, finally, aggregate organism observation themselves. Less organism names and organism names have been added than those parsed, because the Veg-X document already contained some from individual organism observations. We can inspect the newly added taxon cover observations using:
```{r results add agg obs moki}
head(showElementTable(moki_vegx, "aggregateOrganismObservation"),3)
```
The **Mt Fyffe forest** data set includes individual counts by species and stratum (i.e. another kind of aggregate organism observations) in a data frame ``mtfyffe_counts``, which has a similar structure as ``moki_tcv``, but with counts being in column ``value``:
```{r mapping taxon obs mtfyffe}
head(mtfyffe_counts, 3)
mapping = list(plotName = "Plot", subPlotName = "Subplot", obsStartDate = "PlotObsStartDate", 
               taxonName = "NVSSpeciesName", stratumName = "Tier", counts = "Value")
```
Analogously to the previous case, we need to specify a measurement method for counts, and in this case we can use function ``predefinedMeasurementMethod()``:
```{r count scale def}
countscale = predefinedMeasurementMethod("Plant counts")
```
Then we also need to provide the strata definition, which is different from that of the previous data set. Here all strata are defined by height, so we can use a function called ``defineHeightStrata()``:
```{r mtfyffe strata def}
mtfyffe_strataDef = defineHeightStrata(name = "Standard seedling/sapling strata",
                              description = "Seedling/sapling stratum definition",
                              heightBreaks = c(0, 15, 45, 75, 105, 135, 200),
                              strataNames = as.character(1:6),
                              strataDefinitions = c("0-15 cm", "16-45 cm", "46-75 cm", 
                                                    "76-105 cm", "106-135 cm", "> 135 cm"))
```
Now, we are ready to import the data:
```{r add taxon obs mtfyffe}
mtfyffe_vegx = addAggregateOrganismObservations(mtfyffe_vegx, mtfyffe_counts, mapping,
                        methods = c(counts=countscale),
                        stratumDefinition = mtfyffe_strataDef)
head(showElementTable(mtfyffe_vegx, "aggregateOrganismObservation"),3)
```
Again, this involves that elements of several kinds are added to our Veg-X document. The process for the **Takitimu grassland** data set is similar, but in this case, the observations are not organized by strata, and as abundance values we have frequency of occurrence.

```{r mapping taxon obs taki}
head(taki_freq, 3)
mapping = list(plotName = "Plot", obsStartDate = "PlotObsStartDate", 
               taxonName = "NVSSpeciesName", freq = "Value")
```
Hence, we define the new measurement scale and call again ``addAggregateOrganismObservations()``:
```{r freq scale def}
freqscale = predefinedMeasurementMethod("Plant frequency/%")
taki_vegx = addAggregateOrganismObservations(taki_vegx, taki_freq, mapping,
                        methods = c(freq=freqscale))
head(showElementTable(taki_vegx, "aggregateOrganismObservation"), 3)
```
As expected, no stratum definition nor stratum observations are added to the Veg-X document, but we still see the addition of organism names, organism identities and aggregate organism observations.

While aggregated organism observations are often related to strata, it is possible to indicate that measurements of cover of counts were done focusing on a particular height, by mapping to *heightMeasurement* instead of using *stratumName*. 

### Stratum observations

In the previous subsections we stated that both individual and aggregate organism observations can be positioned in a particular vegetation stratum (e.g. the moss layer). However, one could imagine measurements that apply to the stratum itself, like the overall cover or basal area of all organisms in the stratum, regardless of their identity. Other common stratum measurements are those that define its vertical limits (e.g. at which height did the tree layer started?). Veg-X allows storing this information in elements *stratumObservation*. We showed that of this kind these were automatically created and added when dealing with aggregate taxon observations, but here we show how to add measurements that specifically refer to strata using function ``addStratumObservations()``.

To illustrate how to add stratum observations to a Veg-X document, we take again the **Mokihinui forest** data set as data source and inspect the data frame ``moki_str``, which contains strata cover measurements:
```{r inspect str obs moki}
head(moki_str, 3)
```
The data table also contains stratum height limits, although our definition of strata to import taxon cover data already contained height limits for most strata. We will assume that the data in ``moki_str`` indeed contains actual measurements and define the mapping accordingly:
```{r mapping str obs moki}
mapping = list(plotName = "Plot", obsStartDate = "PlotObsStartDate", stratumName = "Tier",
               lowerLimitMeasurement = "TierLower", upperLimitMeasurement = "TierUpper",
               cover = "CoverClass")
```
Both the cover ordinal scale and the strata definitions have been used before, so we do not need to redefine them. We do need, however, to create a definition of the method applying to height measurements, before calling ``addStratumObservations()``:
```{r add str obs moki}
heightMethod = predefinedMeasurementMethod("Stratum height/m")

moki_vegx = addStratumObservations(moki_vegx, moki_str, mapping = mapping,
                        methods = list(lowerLimitMeasurement = heightMethod,
                                       upperLimitMeasurement = heightMethod,
                                       cover=coverscale),
                        stratumDefinition = moki_strataDef)
```
Note that no new strata definitions are added, as they were already included when adding aggregate stratum observations. We do have some new stratum observations. The status of the stratum observations can be shown using:
```{r results str obs moki}
head(showElementTable(moki_vegx, "stratumObservation"), 3)
```

### Surface cover observations

Surface cover observations are measurements of the percentage of the plot's surface that is covered (i.e. when projected onto the ground) by different surface types, such as rocks, bare soil, vegetation, etc. Veg-X allows defining surface types as *surfaceType* elements, and storing  cover values for them in *surfaceCoverObservation* elements. We use the **Mt Fyffe forest** data set to illustrate how this kind of observations are added to a Veg-X document. First we inspect table ``mtfyffe_groundcover`` and define a mapping:
```{r inspect surface obs mtfyffe}
head(mtfyffe_groundcover, 3)
mapping = list(plotName = "Plot", obsStartDate = "PlotObsStartDate",
               surfaceName = "PlotGroundCover", coverMeasurement = "Value")

```
In this case, cover values are specified as percent cover of ground surface, so we need to define an appropriate method:
```{r cover method surface obs mtfyffe}
coverMethod = predefinedMeasurementMethod("Surface cover/%")
```
We inspect the surface types used in the data set and call function ``defineSurfaceTypes()`` as we have done previously for strata:
```{r surface types mtfyffe}
unique(mtfyffe_groundcover$PlotGroundCover)
surfaceTypes = defineSurfaceTypes(name = "Default surface types",
                     description = "Five surface categories",
                     surfaceNames = c("Vegetation", "Moss", "Litter", "Exposed Soil", 
                                      "Rock"))
```
We can now import surface cover observations using function ``addSurfaceCoverObservations()``:
```{r add surface obs mtfyffe}
mtfyffe_vegx = addSurfaceCoverObservations(mtfyffe_vegx, mtfyffe_groundcover, mapping,
                                coverMethod, surfaceTypes)

head(showElementTable(mtfyffe_vegx, "surfaceCoverObservation", 3))
```
Analogously to the case of strata, the function added surface type definitions to the Veg-X document, in addition to adding the cover values, themselves. 

The **Takitimu grassland** data set also includes surface cover observations, although the surface types are slightly different:
```{r inspect surface obs taki}
head(taki_groundcover, 3)
unique(taki_groundcover$PlotGroundCover)
```
Therefore, we must define a new set of surface types before calling function ``addSurfaceCoverObservations()``:
```{r add surface obs taki}
surfaceTypes = defineSurfaceTypes(name = "Default surface types",
                     description = "Five surface categories",
                     surfaceNames = c("Vegetation", "Soil", "Erosion Pavement", "Litter",
                                      "Rock"))

taki_vegx = addSurfaceCoverObservations(taki_vegx, taki_groundcover, mapping,
                                coverMethod, surfaceTypes)
```


### Site observations
Veg-X includes into elements *siteObservation* all observations and measurements that do not refer to vegetation itself, i.e. abiotic measurements, soil type classifications, etc. Since our example source data sets did not include any of such measurements, we created a column ``pH`` with constant values in the ``moki_site`` data frame. The function that allows adding site observations is ``addSiteObservations()`` and the following code should be self-explanatory by now:
```{r add site obs moki}
mapping = list(plotName = "Plot", subPlotName = "Subplot", obsStartDate = "PlotObsStartDate")
pHMeth = predefinedMeasurementMethod("pH")
moki_vegx = addSiteObservations(moki_vegx, moki_site,
                         plotObservationMapping = mapping,
                         soilMeasurementMapping = list(pH = "pH"),
                         soilMeasurementMethods = list(pH = pHMeth))
head(showElementTable(moki_vegx, "siteObservation"))
```

## Combining and harmonizing Veg-X documents

One of the purposes of importing data into Veg-X, is the possibility to combine and harmonize documents from different sources. In this section we illustrate how documents can be merged, and some (preliminary) functions that can be used to harmonize their contents.

### Updating taxon nomenclature

```{r inspect tax id moki}
head(showElementTable(moki_vegx, "organismIdentity"),10)
```

```{r transf tax id moki}
moki_vegx = transformTaxonNomenclature(moki_vegx, moki_lookup,
                   c(originalOrganismName = "NVSSpeciesName", preferredTaxonName = "PreferredSpeciesName"))
```

```{r result tax id moki}
a = showElementTable(moki_vegx, "organismIdentity")
a[which(a$identityName!= a$originalOrganismName),]
```

```{r transf tax id mtfyffe}
mtfyffe_vegx = transformTaxonNomenclature(mtfyffe_vegx, mtfyffe_lookup,
                   c(originalOrganismName = "NVSSpeciesName", preferredTaxonName = "PreferredSpeciesName"))
a = showElementTable(mtfyffe_vegx, "organismIdentity")
a[which(a$identityName!= a$originalOrganismName),]
```

```{r transf tax id taki}
taki_vegx = transformTaxonNomenclature(taki_vegx, taki_lookup,
                   c(originalOrganismName = "NVSSpeciesName", preferredTaxonName = "PreferredSpeciesName"))
a = showElementTable(taki_vegx, "organismIdentity")
a[which(a$identityName!= a$originalOrganismName),]
```

### Merging two Veg-X documents
Function ``mergeVegX()`` is used to merge two Veg-X documents into a single one. This function puts all the input elements into the same containers and, whenever elements are considered to be the same, they are merged. Each element kind has its own way to determine when two instances refer to the same entity. For example, two plots will be considered to be equal if they have the same plot name. A call to ``mergeVegX()`` produces the following output:
```{r merge two documents}
comb_vegx = mergeVegX(moki_vegx, mtfyffe_vegx)
```
The two documents to be merged, ``mtfyffe_vegx`` and ``taki_vegx`` had shared methods, so the function identifies them as equal and avoids repetitions. In contrast, the plots had all different names, so they were all kept separately (in this case, merging plots would be considered a mistake, as they come from different study areas). The decisions to merge (i.e. pool) information of other elements can be interpreted similarly. A case of special rellevance concerns *organismName* vs. *organismIdentity*. Note that some organism names were merged, but identities were not. While merging equal names is always safe, merging identities should be done with caution, because two data sets may have employed the same taxon name but with different taxon concepts. Therefore, by default ``mergeVegX()`` does not merge organism identities. If we want to specify that identities can be merged (when considered equal) we can set parameter ``mergeIdentities = TRUE``:
```{r merge two documents identities}
# comb_vegx = mergeVegX(moki_vegx, mtfyffe_vegx, mergeIdentities = TRUE)
```
Note that in this second output, there are the number of merges in *organismName* than *organismIdentity*, as the equal names have been forced to mean equal identity.

Note that function ``mergeVegX()`` can also be used to merge two documents that refer to the same data source, i.e. if one has imported different parts of the same source data into different Veg-X documents. 

### Transforming quantitative scales

```{r transform height}
heightMethod2 = predefinedMeasurementMethod("Stratum height/cm")
trans_vegx = transformQuantitativeScale(comb_vegx, "Stratum height/m", heightMethod2,
                               function(x){return(x*10)}, replaceValues = TRUE)
head(showElementTable(trans_vegx, "stratumObservation"),3)
```

### Transforming ordinal scales

```{r transform cover}
percentScale = predefinedMeasurementMethod("Plant cover/%")
trans_vegx = transformOrdinalScale(comb_vegx, "Recce cover scale", percentScale)
head(showElementTable(trans_vegx, "stratumObservation"),3)
```


head(showElementTable(, "organismIdentity"))

## Writing and reading Veg-X documents

The **Veg-X exchange standard** is currently implemented as an **XML schema** (but other physical implementations of the standard could be possible). The VegX package provides functions ``writeVegX()`` and ``readVegX()`` that are used, respectively, to write and read XML files with Veg-X documents. An advantage of XML is that it is text that can be read and understood by humans, but its disadvantage is that files tend to be very large, because of the redundancy of text. One possibility to overcome this is to compress XML files (into zip or tar.gz files) for more efficient storage. However, compressing XML files does not avoid the problem that writing/reading XML files can be slow in large data sets. 

An alternative to XML that users can employ is to directly save and read Veg-X documents as R objects, using functions ``saveRDS()``and ``readRDS()``. This option is fast and will produce much smaller files. The only drawback of saving R objects can arise if the S4 definition of Veg-X documents is changed in future versions of the package. We tried to avoid this potential problem by defining S4 Veg-X objects as lists of the main elements, without defining the internal structure of each main element. If the version of the standard is changed, functions to convert R objects from old to new versions of the standard should be made available to avoid losing backwards compatibility, in the same way that function ``readVegX()`` should be modified to allow reading XML documents formed following old versions of the standard.


